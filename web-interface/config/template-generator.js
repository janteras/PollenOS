
const fs = require('fs');
const path = require('path');

class ConfigTemplateGenerator {
    constructor() {
        this.strategies = {
            'conservative': [25, 20, 15, 15, 10, 10, 5],
            'momentum': [30, 25, 15, 10, 10, 5, 5],
            'technical': [20, 20, 20, 15, 10, 10, 5],
            'mean-reversion': [22, 18, 18, 16, 12, 8, 6],
            'breakout': [35, 20, 15, 10, 10, 5, 5],
            'scalping': [25, 20, 20, 15, 10, 5, 5],
            'grid-trading': [28, 22, 18, 12, 10, 6, 4],
            'high-frequency': [40, 20, 12, 10, 8, 6, 4],
            'liquidity-provision': [18, 17, 16, 15, 14, 12, 8],
            'cross-chain-arbitrage': [32, 22, 16, 12, 8, 6, 4]
        };
    }
    
    generateWalletConfig(bots) {
        const walletConfig = {
            BOTS: bots.map((bot, index) => ({
                name: this.sanitizeName(bot.name),
                privateKey: bot.privateKey,
                strategy: bot.strategy,
                riskLevel: bot.riskLevel || 'medium',
                autoRebalance: bot.autoRebalance !== false,
                weights: this.strategies[bot.strategy] || this.strategies['conservative']
            }))
        };
        
        return this.generateConfigFileContent('wallets.js', walletConfig);
    }
    
    generateMultiBotConfig(bots, network = 'base-sepolia') {
        const config = {
            network: network,
            totalBots: bots.length,
            strategies: {},
            botConfigs: {}
        };
        
        bots.forEach((bot, index) => {
            const botId = index + 1;
            config.strategies[`bot${botId}`] = bot.strategy;
            config.botConfigs[`bot${botId}`] = {
                name: bot.name,
                strategy: bot.strategy,
                riskLevel: bot.riskLevel,
                autoRebalance: bot.autoRebalance,
                weights: this.strategies[bot.strategy] || this.strategies['conservative']
            };
        });
        
        return this.generateConfigFileContent('multi-bot-config.js', config);
    }
    
    generateEnvConfig(network, customRpc = null) {
        const envConfig = {
            // Network configuration
            NETWORK: network,
            RPC_URL: customRpc || this.getDefaultRpcUrl(network),
            CHAIN_ID: this.getChainId(network),
            
            // Contract addresses based on network
            ...this.getContractAddresses(network),
            
            // Trading configuration
            TRADING_ENABLED: 'true',
            AUTO_REBALANCE: 'true',
            GAS_LIMIT: '300000',
            GAS_PRICE_MULTIPLIER: '1.1',
            
            // Monitoring
            LOG_LEVEL: 'info',
            ENABLE_NOTIFICATIONS: 'true',
            STATUS_UPDATE_INTERVAL: '30000'
        };
        
        return this.generateEnvFileContent(envConfig);
    }
    
    sanitizeName(name) {
        return name.toLowerCase().replace(/[^a-z0-9]/g, '_').replace(/_+/g, '_');
    }
    
    getDefaultRpcUrl(network) {
        const rpcUrls = {
            'base-sepolia': 'https://sepolia.base.org',
            'avalanche-mainnet': 'https://api.avax.network/ext/bc/C/rpc'
        };
        return rpcUrls[network] || rpcUrls['base-sepolia'];
    }
    
    getChainId(network) {
        const chainIds = {
            'base-sepolia': '84532',
            'avalanche-mainnet': '43114'
        };
        return chainIds[network] || chainIds['base-sepolia'];
    }
    
    getContractAddresses(network) {
        const contracts = {
            'base-sepolia': {
                FACTORY_ADDRESS: '0x8b312F4503790cBD1030B97C545C7F3EfDADE717',
                VEPLN_ADDRESS: '0x2eCB6F9dF29163758024d416997764922E4528d4',
                PLN_TOKEN_ADDRESS: '0x2eCB6F9dF29163758024d416997764922E4528d4'
            },
            'avalanche-mainnet': {
                FACTORY_ADDRESS: '0x8b312F4503790cBD1030B97C545C7F3EfDADE717',
                VEPLN_ADDRESS: '0x2eCB6F9dF29163758024d416997764922E4528d4',
                PLN_TOKEN_ADDRESS: '0x2eCB6F9dF29163758024d416997764922E4528d4'
            }
        };
        return contracts[network] || contracts['base-sepolia'];
    }
    
    generateConfigFileContent(filename, config) {
        const timestamp = new Date().toISOString();
        const header = `/**
 * ${filename}
 * Auto-generated by PollenOS Configuration Interface
 * Generated: ${timestamp}
 * 
 * This file is dynamically created based on user configuration.
 * Manual changes will be overwritten on next configuration update.
 */

`;
        
        if (filename.endsWith('.js')) {
            return header + `module.exports = ${JSON.stringify(config, null, 2)};`;
        }
        
        return header + JSON.stringify(config, null, 2);
    }
    
    generateEnvFileContent(config) {
        const timestamp = new Date().toISOString();
        let content = `# Auto-generated by PollenOS Configuration Interface
# Generated: ${timestamp}
# 
# This file is dynamically created based on user configuration.
# Manual changes will be overwritten on next configuration update.

`;
        
        Object.entries(config).forEach(([key, value]) => {
            content += `${key}=${value}\n`;
        });
        
        return content;
    }
    
    writeConfigFile(filepath, content) {
        const dir = path.dirname(filepath);
        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }
        
        fs.writeFileSync(filepath, content);
        console.log(`Generated configuration file: ${filepath}`);
    }
    
    generateAllConfigs(bots, network = 'base-sepolia', customRpc = null, outputDir = '../../../config') {
        const configs = [];
        
        // Generate wallets.js
        const walletsContent = this.generateWalletConfig(bots);
        const walletsPath = path.join(__dirname, outputDir, 'wallets.js');
        this.writeConfigFile(walletsPath, walletsContent);
        configs.push(walletsPath);
        
        // Generate multi-bot-config.js
        const multiBotContent = this.generateMultiBotConfig(bots, network);
        const multiBotPath = path.join(__dirname, '../../..', 'multi-bot-config.js');
        this.writeConfigFile(multiBotPath, multiBotContent);
        configs.push(multiBotPath);
        
        // Generate environment config
        const envContent = this.generateEnvConfig(network, customRpc);
        const envPath = path.join(__dirname, outputDir, `${network}-generated.env`);
        this.writeConfigFile(envPath, envContent);
        configs.push(envPath);
        
        return configs;
    }
    
    validateBotConfiguration(bot) {
        const errors = [];
        
        if (!bot.name || bot.name.trim().length === 0) {
            errors.push('Bot name is required');
        }
        
        if (!bot.privateKey || !bot.privateKey.match(/^0x[a-fA-F0-9]{64}$/)) {
            errors.push('Valid private key is required (64 hex characters with 0x prefix)');
        }
        
        if (!bot.strategy || !this.strategies[bot.strategy]) {
            errors.push('Valid strategy is required');
        }
        
        if (!['low', 'medium', 'high'].includes(bot.riskLevel)) {
            errors.push('Risk level must be low, medium, or high');
        }
        
        return errors;
    }
    
    validateConfiguration(bots, network) {
        const errors = [];
        
        if (!Array.isArray(bots) || bots.length === 0) {
            errors.push('At least one bot configuration is required');
        }
        
        if (bots.length > 20) {
            errors.push('Maximum 20 bots allowed');
        }
        
        const names = new Set();
        bots.forEach((bot, index) => {
            const botErrors = this.validateBotConfiguration(bot);
            botErrors.forEach(error => errors.push(`Bot ${index + 1}: ${error}`));
            
            if (names.has(bot.name)) {
                errors.push(`Bot ${index + 1}: Duplicate bot name "${bot.name}"`);
            }
            names.add(bot.name);
        });
        
        if (!['base-sepolia', 'avalanche-mainnet'].includes(network)) {
            errors.push('Unsupported network');
        }
        
        return errors;
    }
}

module.exports = ConfigTemplateGenerator;
